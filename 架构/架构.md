### 架构

#### 概述

ROS架构包含三层，OS层，中间层和应用层。

#### OS层

依托与linux的系统内核

#### 中间层

##### 通讯系统

采用发布/订阅、客户机/服务器等模型，还有多种数据传输方式。

* TCPROS/UDPROS，针对TCP/UDP网络进行再次封装。
* Nodelet一种多进程间通信方式，具有高实时的特点

#### 应用层

在应用层中需要一个master结点，开发人员在使用模块时无需关注模块内部实现的机制，只要了解接口规则即可。

从系统实现来看，ROS包含三个层次：文件系统、计算图和开源社区

计算图：

以计算图的角度看，以结点单独运行，功能模块可以安装在同一主机上，也可以不在同一个网络上。

消息：
结点间的基于发布/订阅模型的消息通信。每一个消息都是严格的数据结构。（疑问：这里涉及到如何封装以及该数据结构如何存储信息，这两个过程是如何实现的。类似于gRPC的序列化吗？）

话题：
类似与邮箱机制，有push，pull两种操作。在ROS表示为发布/订阅模型，结点可以根据给定的话题发布消息或者订阅消息。可以有多个结点发布或订阅同一话题。

服务：

在上面我们提到的“话题”不利于信息的同步传输。因此，在ROS中将同步传输模式称为服务，其基于客户端/服务器模型，类似于web服务器。只允许一个结点提供指定命名服务。

<table>
    <tr>
        <td>类型</td>
        <td>消息</td>
        <td>话题</td>
        <td>服务</td>
    </tr>
    <tr>
        <td>服务模式</td>
        <td>基于基本的数据结构</td>
        <td>通过发布/订阅模式</td>
        <td>通过客户端/服务器模式</td>
    </tr>
    <tr>
        <td>与结点间关系</td>
        <td></td>
        <td>多个结点可以发布/订阅同一话题</td>
        <td>只允许有一个结点提供指定命令的服务（同一服务只允许一个结点发布）</td>
    </tr>
    <tr>
        <td>特点</td>
        <td></td>
        <td>异步</td>
        <td>同步传输</td>
    </tr>
</table>


通过结点管理器（ROS Master）来控制结点。ROS Master通过远程过程调用（RPC）提供**列表的登记**以及**其他计算图表的查询功能**。

##### 文件系统

* **功能包**是**ROS软件中的基本单元**，包含

  * ROS结点
    * msg：放置功能包自定义的消息类型
    * src：放置功能包自定义的服务类型
    * action：放置功能包自定义的动作指令
    * package.xml：功能包清单
  * 启动运行相关
    * script：放置可以直接运行的python脚本
    * launch：放置功能包的所有启动文件
  * 代码相关
    * include：功能包需要用到的头文件
    * src：放置需要编译的c++代码
    * CMakeLists.txt：编译器编译功能包的规则
  * 配置信息
    * config：功能包配置文件

* **功能包清单**用于用于记录功能包的基本信息，包含作者信息、许可信息、依赖选项、编译标志等

* **元功能包**是实现**某一类特殊活动所需的功能集合**，故是功能包的上级概念。

  **元功能包是一种特殊的功能包**，只包含package.xml元功能包清单文件。它主要的作用是将多个功能整合成一个逻辑上的独立的功能包。

* **元功能清单**包含该功能模块**需要依赖的功能包**或者**声明引用标签**

* 消息类型：消息是ROS结点之间发布/订阅的通信消息。有两种类型供选择

  * ROS提供的消息类型
  * 使用.msg文件在功能包的msg文件下自定义所需要的消息类型。

* 服务类型：服务类型定义了ROS客户端/服务器通信模型下的请求与应答数据类型

  * 可以使用ROS系统提供的服务类型
  * 使用.srv文件在功能包的src文件夹中进行定义

* 代码：用来放置功能包结点源代码的文件夹

#### ROS的通信机制——分布式通信机制

##### 话题通信机制（P2P）

角色有Talker、Listener和ROS Master

1. talker启动，通过1234端口使用RPC向ROS Master注册发布者的信息，包含所发布的话题名；ROS Master将结点的注册信息加入注册列表中。
2. listener启动，通过RPC向ROS Master注册订阅者的信息，以及需要订阅的话题。
3. ROS Master根据listener的订阅消息从注册列表中查找；如果找到，则通过RPC向listener发送talker的RPC地址信息；如果找不到，则等待发布者的加入。
4. listener收到ROS Master发送的talker的地址信息，尝试通过RPC向talker发送连接请求和订阅的话题名、消息类型以及通信类型。
5. talker收到以后，继续通过RPC向listener确认连接信息，其包含自身的tcp信息
6. listener尝试与talker建立网络连接（tcp）
7. talker向listener发布话题信息数据

服务通信机制

1. talker启动，通过1234端口使用RPC向ROS Master注册发布者信息以及 发布的话题。ROS Master将注册信息保存到注册表上。
2. listener启动，使用RPC向ROS Master结点注册订阅者信息以及待查找的服务名
3. ROS Master根据listener的订阅消息从注册表中查找相应表项；如果查找失败，等待服务的提供者加入；如果找到，则通过RPC向listener发送talker的tcp地址信息
4. listener接收到来自ROS Mater的确认消息后，使用TCP尝试与talker建立网络连接，并且发送服务的请求数据
5. talker接收到服务请求和参数后，开始执行服务功能，执行完成后，向listener发送应答数据。




